[
  
  {
    "title": "kubectl command book",
    "url": "/blog/posts/kubectl-command-book/",
    "categories": "Kubernetes",
    "tags": "Kubernetes, CLI",
    "date": "2024-08-20 20:39:00 -0500",
    





    
    "snippet": "This is my digital command book for  kubectl commands to interact with K8s clusters. This is a work in progress and will be updated with more detail + descriptions as I go.kubectl command bookBasic...",
    "content": "This is my digital command book for  kubectl commands to interact with K8s clusters. This is a work in progress and will be updated with more detail + descriptions as I go.kubectl command bookBasic commands for managing Kubernetes contexts and configurations.            Command      Description                  kubectl config get-contexts      List all available contexts and show which one is currently active.              kubectl config use-context $context$      Switch to a different context.      OperationsCommon operations for managing Kubernetes resources.            Command      Description      Example                  kubectl apply      Apply a configuration to a resource by file or stdin.      kubectl apply -f ./my-manifest.yaml              kubectl create      Create a resource from a file or from stdin.      kubectl create -f ./my-resource.yaml              kubectl run      Run a particular image on the cluster.      kubectl run my-nginx --image=nginx              kubectl explain      Get documentation for a resource.      kubectl explain pods              kubectl get      List one or more resources.      kubectl get pods              kubectl get pods      List all pods in the namespace.      kubectl get pods              kubectl describe      Show detailed information about a resource.      kubectl describe pods my-pod              kubectl exec      Execute a command in a container.      kubectl exec -it my-pod -- /bin/bash              kubectl logs      Print the logs for a container in a pod.      kubectl logs my-pod      Resource AliasesShortcuts for commonly used Kubernetes resources.            Resource      Alias                  nodes      no              pods      po              services      svc      Output OptionsOptions for formatting the output of kubectl commands.            Command      Description                  -o wide      Output additional information.              -o yaml      Output the resource in YAML format.              -o json      Output the resource in JSON format.              --dry-run      Simulate the command without making any changes.      Options for adjusting verbosity in output| Verbosity | Description                                                                                                                                                                                                 ||———–|————————————————————————————————————————————————————————————————————-|| --v=0   | Generally useful for this to ALWAYS be visible to an operator.                                                                                                                                               || --v=1   | A reasonable default log level if you don’t want verbosity.                                                                                                                                                  || --v=2   | Useful steady state information about the service and important log messages that may correlate to significant changes in the system. This is the recommended default log level for most systems.             || --v=3   | Extended information about changes.                                                                                                                                                                          || --v=4   | Debug level verbosity.                                                                                                                                                                                       || --v=6   | Display requested resources.                                                                                                                                                                                 || --v=7   | Display HTTP request headers, including Application-Type and User Agent.                                                                                                                                     || --v=8   | Display HTTP request contents.                                                                                                                                                                               || --v=9   | Display HTTP request contents without truncation of contents.                                                                                                                                                |Cluster InformationCommands for retrieving information about the Kubernetes cluster and its resources.            Command      Description                  kubectl cluster-info      Display cluster information.              kubectl get nodes      List all nodes with their status, roles, age, and version.              kubectl get nodes -o wide      List all nodes with additional information like IPs and kernel versions.              kubectl get pods      List all pods in the default namespace.              kubectl get pods --namespace redis      List all pods in the redis namespace.              kubectl get all --all-namespaces      List all resources in all namespaces.              kubectl api-resources      List all available resource types.              kubectl explain pod      Show detailed documentation for the pod resource.              kubectl explain pod.spec      Show detailed documentation for the pod spec.              kubectl explain pod.spec.containers      Show detailed documentation for the pod containers spec.              kubectl explain pod --recursive      Show detailed documentation for the pod resource and all its fields.      Node InformationCommands for retrieving detailed information about nodes in the cluster.            Command      Description      Example                  kubectl describe nodes &lt;node&gt;      Show detailed information about a specific node.      kubectl describe nodes aks-nodepool1-30702851-vmss000000      Help CommandsCommands for getting help and documentation for kubectl commands.            Command      Description      Example                  kubectl -h      Show help for kubectl.      kubectl get -h              kubectl create -h      Show help for the create command.      kubectl create -h      Deployment (Imperative)Commands for creating and managing deployments imperatively.            Command      Description                  kubectl create deployment nginx --image=nginx      Create a deployment named nginx with the nginx image.              kubectl run nginx --image=nginx      Start a pod named nginx with the nginx image.      Deployment (Declarative)Define the desired state in code using a manifest in YAML or JSON, then use kubectl apply -f deployment.yml.            Command      Description                  kubectl apply -f deployment.yml      Apply the deployment configuration from a YAML file.      Deploying Resources ImperativelyCommands for creating and managing resources imperatively.            Command      Description                  kubectl create deployment hello-world --image=redis:alpine      Create a deployment named hello-world with the redis:alpine image.              kubectl run hello-world-pod --image=redis:alpine      Start a pod named hello-world-pod with the redis:alpine image.              kubectl create deployment hello-world --image=$image --dry-run=client -o yaml &gt; deployment.yaml      Generate a deployment YAML file without creating the deployment.              kubectl get deployment hello-world      List the hello-world deployment.              kubectl get replicaset      List all ReplicaSets.              kubectl describe deployment hello-world      Show detailed information about the hello-world deployment.              kubectl describe replicaset hello-world      Show detailed information about the hello-world ReplicaSet.              kubectl describe pod hello-world      Show detailed information about the hello-world pod.              kubectl expose deployment hello-world --port=80 --target-port=8080      Expose the hello-world deployment as a service.              kubectl get service hello-world      List the hello-world service.              kubectl describe service hello-world      Show detailed information about the hello-world service.              curl http://$SERVICEIP:PORT      Access the hello-world service inside the cluster.              kubectl get endpoints hello-world      List the endpoints for the hello-world service.              kubectl get deployment hello-world -o yaml      Output the hello-world deployment in YAML format.              kubectl get deployment hello-world -o json      Output the hello-world deployment in JSON format.      Deployment DeclarativelyCommands for creating and managing deployments declaratively.            Command      Description                  kubectl create deployment hello-world --image=redis:alpine --dry-run=client -o yaml      Generate a deployment YAML file without creating the deployment.              more deployment.yml      View the contents of the deployment.yml file.              kubectl deploy      Deploy the resources defined in the YAML files.              kubectl expose &gt; service.yml      Generate a service YAML file using the expose command.              kubectl apply -f service.yml      Apply the service YAML file to create the service.              kubectl get all      List all resources including State, Deployment, ReplicaSet, Pod, and Service.              kubectl get service hello-world      List the hello-world service.              kubectl edit deployment hello-world      Edit the hello-world deployment on the fly.              kubectl scale deployment hello-world --replicas=40      Scale the hello-world deployment to 40 replicas.              kubectl diff -f deployment-new.yaml      Diff that with the current deployment file to narrow down where the changes are.      LogsCommands for retrieving logs from containers and troubleshooting.            Command      Description      Example                  kubectl logs $podname$      Print the logs for a specific pod.      kubectl logs hello-world-pod      # This is how you can remote into a container.kubectl exec -it redis -- /bin/shhostnameip addrexit"
  },
  
  {
    "title": "Navigating Environment-Specific Deployments with GitHub",
    "url": "/blog/posts/locking-down-tag-based-releases-from-envirionments/",
    "categories": "GitHub",
    "tags": "GitHub, GitHub Actions, CI/CD, DevOps",
    "date": "2024-08-18 01:21:00 -0500",
    





    
    "snippet": "Locking Down Tag-Based Releases from EnvironmentsAs a DevOps engineer, I’ve always found tag-based releases to be a powerful tool for managing deployments across multiple environments. They offer a...",
    "content": "Locking Down Tag-Based Releases from EnvironmentsAs a DevOps engineer, I’ve always found tag-based releases to be a powerful tool for managing deployments across multiple environments. They offer a level of precision and control that’s hard to match. But the challenge lies in ensuring that only the right branches - those that are production-ready - get deployed in a CI/CD pipeline. Let’s dive into how GitHub’s release feature can help us streamline this process. With GitHub, you can create a “release” which creates a tag that can be automatically deployed through the environments. But what if you want to restrict certain branches from being deployed to specific environments, like production?graph TB    A[GitHub] --&gt;|Create Release| B[Base tag off feature/* branch]    B --&gt;|Automatic Deployment| C[Development Environment]    C --&gt; D[Staging Environment]    D --&gt;|Restrict all branches except head branch| E[Production Environment]Let’s say you have a feature branch that you want to test in a staging environment, but you don’t want it to go to production. This is where you can leverage GitHub Actions to control the flow of your deployments.Option 1: Navigating the PreRelease and Release WatersGitHub’s “prerelease” and “release” options can seem like a handy way to steer deployments. Marking a release as “prerelease” can help differentiate production-ready versions from others.But this method does have a catch: It’s too easy for someone to accidentally mark a feature or test branch as a “release”, leading to an unintended production deployment.So, while “prereleases” can be a tool in your deployment strategy, they’re not a failsafe for controlling deployments to specific environments.graph LR    A[GitHub] --&gt;|Accidental Mark as Release| B[Feature/Test Branch]    B --&gt; C[Unintended Production Deployment]    A --&gt;|Create Release| D[Production-Ready Version]    D --&gt; E[Controlled Production Deployment]    style A fill:#f9d0c4,stroke:#333,stroke-width:4px    style B fill:#e2a4a4,stroke:#333,stroke-width:4px    style C fill:#e66767,stroke:#333,stroke-width:4px    style D fill:#9ddfd3,stroke:#333,stroke-width:4px    style E fill:#59c9a5,stroke:#333,stroke-width:4pxOption 2: Using Git to Determine Tag and Branch RelationshipThe git branch --contains tags/$tag command can identify branches associated with a specific tag. However, it has limitations. If a branch that contains the tag is merged into the master branch, the tag will also be part of the master branch. This is because when you merge a branch, you’re merging its commit history, which includes any tags associated with those commits.This could result in deploying code that doesn’t match the current master branch state, especially if additional commits were added post-merge. Conversely, this can be useful for rollbacks to a previous code state.Using git commands is not foolproof for ensuring a tag matches a specific branch’s current state. Use it cautiously in deployment processes.gitGraph   commit id: \"Initial commit\"   branch develop   checkout develop   commit id: \"develop work\"   branch feature   checkout feature   commit id: \"feature work\"   checkout develop   merge feature tag: \"v1.1\"   checkout main   merge develop tag: \"v1.2\"Option 3: Using GitHub Action’s Event Trigger to Identify the Original Branch of a TagYou can use GitHub Actions to trigger events based on repository activity, such as a release being published. By accessing the github.event.release.target_commitish and github.event.repository.default_branch variables, you can determine the original branch of a tag.The github.event.release.target_commitish specifies the commitish (branch) value that determines where the Git tag is created from. The github.event.repository.default_branch` is the default branch of the repository and can be used to compare with the tag’s original branch.This method allows you to restrict deployments to production based on the original branch of a tag. Specifically, you can check if the tag’s original branch matches the repository’s default branch before deploying to production.So in your deployment job, you’d want to include an if statement like,if: $Here’s a sample release workflow that demonstrates this approach:name: Releaseon:  release:    types:      - publishedjobs:  Build:     runs-on: ubuntu-latest    steps:      - name: Build        run: |          # Build Commands          echo \"Building app...\"  Deploy-To-Staging:    runs-on: ubuntu-latest    needs: [Build]    environment:      name: Staging    steps:      - name: Get variables        run: |            echo $            echo $  Deploy-To-Production:    runs-on: ubuntu-latest    needs: [Build, Deploy-To-Staging]    if: $    environment:      name: Production    steps:      - name: Get Event        run: cat $GITHUB_EVENT_PATH"
  },
  
  {
    "title": "Using ForEach() Method for Array Iteration",
    "url": "/blog/posts/explain-code-gh-copilot/",
    "categories": "",
    "tags": "powershell, dotnet, github, copilot",
    "date": "2024-05-13 05:21:00 -0500",
    





    
    "snippet": "I learned about a nifty ForEach() powershell method when looping through an array. You can call it on a collection and pass a script block to it!Context:I was recently reading the new docs for GitH...",
    "content": "I learned about a nifty ForEach() powershell method when looping through an array. You can call it on a collection and pass a script block to it!Context:I was recently reading the new docs for GitHub copilot on how you can now use it in the CLI. GitHub launched the gh copilot explain and gh copilot suggest commands as part of the copilot extension in the GitHub CLI.Example Problem:How can I get an explanation of all of the sql files in a folder?Example Solution:$files = @($(Get-ChildItem -Path .\\ -r -Filter *.sql))$files.foreach{gh copilot explain $(Get-Content $PSItem)}Refernces  PowerShell Array ForEach  GitHub Copilot CLI  Script Blocks"
  },
  
  {
    "title": ".NET Methods Don't Expand Paths",
    "url": "/blog/posts/relative-paths-dotnet/",
    "categories": "",
    "tags": "powershell, dotnet",
    "date": "2024-04-19 15:23:00 -0500",
    





    
    "snippet": "Relative paths are interpreted differently in .NET methods than in PowerShell.ProblemI encountered an error when working with the .NET namespace System.Security.Cryptography.X509Certificates. Despi...",
    "content": "Relative paths are interpreted differently in .NET methods than in PowerShell.ProblemI encountered an error when working with the .NET namespace System.Security.Cryptography.X509Certificates. Despite being in the directory where the certificate file was located, the system could not find the file and threw an exception.While PowerShell automatically resolves relative paths based on the current directory, .NET methods do not. In .NET, when you provide a relative path, it is interpreted relative to the current working directory of the application process, not necessarily the location of the script/executable.ResolutionI resolved it by calling the class using the expanded full path of the certificate.[Security.Cryptography.X509Certificates.X509Certificate2]::New([System.IO.Path]::GetFullPath((Join-Path (Get-Location) $Certificate)))By using System.IO.Path.GetFullPath, I was able to provide the full path of the certificate file to the .NET method, which successfully loaded the certificate.References  System.IO.Path.GetFullPath Method  X509Certificate2 Constructor  Join-Path"
  },
  
  {
    "title": "My CCNA Command Book",
    "url": "/blog/posts/ccna-command-book/",
    "categories": "CCNA, Cisco",
    "tags": "Cisco, Routing and Switching",
    "date": "2021-02-06 00:17:00 -0600",
    





    
    "snippet": "CCNA CommandsHere’s a PDF of the command book I created to pass the CCNA 200-301. I will one day convert this into an easy to read Markdown format, but for the time being, I’ve left it downloadable...",
    "content": "CCNA CommandsHere’s a PDF of the command book I created to pass the CCNA 200-301. I will one day convert this into an easy to read Markdown format, but for the time being, I’ve left it downloadable. Please contact me if you need a .docx version of this document so you can edit."
  },
  
  {
    "title": "OSPF Convergence with Messages, Data Structures and the Dijkstra Algorithm",
    "url": "/blog/posts/ospf-convergence/",
    "categories": "CCNA",
    "tags": "Routing and Switching",
    "date": "2021-01-05 01:29:00 -0600",
    





    
    "snippet": "What is OSPF?Open Shortest Path First (OSPF) is a link-state routing protocol that uses the Dijkstra’s Shortest Path First (SPF) Algorithm to calculate the best paths through the network.OSPF is a ...",
    "content": "What is OSPF?Open Shortest Path First (OSPF) is a link-state routing protocol that uses the Dijkstra’s Shortest Path First (SPF) Algorithm to calculate the best paths through the network.OSPF is a classless, vendor-neutral routing protocol that supports VLSM and CIDR. It sends the entire routing table to its neighbors, which is called the Link State Database (LSDB). OSPF routers use the LSDB to calculate the best routes through the network.Convergence in OSPF is the process of routers learning about the network topology and creating the best routes through the network. Convergence is the process of establishing OSPF neighbor adjacencies, creating the Link State Database (LSDB), and calculating the best routes through the network.Messages Used in OSPF Convergence  Hello  Database Description  Link State Request  Link State Update  Link State AcknowledgeThe Hello Messages are used for knowing the routers’ neighbors and maintain adjacency.Once the Neighbor Adjacency is established, a Database Description message is used to describe the LSDB so that the routers can make sure the LSDBs are in sync throughout the network.Once the adjacency is established, the routers exchange Link State Advertisements (LSAs). These advertisements are flooded throughout the network until each router has each other’s LSAs. LSAs contain the state and cost of each directly connected link.Even if the LSDB is synchronized, there could still be LSAs that are missing in the database. The Link State Request (LSR) message is used to inform OSPF neighbors to send the most current version of the missing LSAs.The Link State Update messages are sent to directly connected neighbors who have requested LSRs.Link State Acknowledgement (LSAck) messages make the flooding of LSAs reliable. Each LSA must be explicitly acknowledged. Multiple LSAs can be acknowledged in a single LSAck packet.Once the Adjacency Database and LSDB is created, the router uses Dijkstra’s SPF Algorithm to calculate the Forwarding Database. The SPF Algorithm creates an SPF Tree with all of the routes calculated with the speed and cost throughout the network and updates the routing table with the best possible routes.  The Hello Messages → Neighbor Adjacency Table  The Database Description and LSAs → LinkState Database  The SPF Algorithm → SPF Tree → Forwarding Database"
  },
  
  {
    "title": "How is Spanning Tree Protocol Established?",
    "url": "/blog/posts/spanning-tree-protocol/",
    "categories": "CCNA",
    "tags": "Routing and Switching",
    "date": "2020-09-23 13:43:00 -0500",
    





    
    "snippet": "Spanning Tree ProtocolImagine you are a switch. You are connected to another switch, and both of you are connected to a third switch. If you send a broadcast message to the internet, it will go thr...",
    "content": "Spanning Tree ProtocolImagine you are a switch. You are connected to another switch, and both of you are connected to a third switch. If you send a broadcast message to the internet, it will go through all of the switches connected to you, and then back. This causes a loop, and the broadcast message will continue to loop through the switches until the network is congested.Spanning Tree Protocol (STP) is a layer 2 protocol that prevents loops in a network by disabling redundant paths between switches.How is Spanning Tree Protocol Established?Spanning Tree Protocol is established by the following steps:1. Determine the Root BridgeThe Root Bridge is selected from the lowest Bridge ID, which consists of the default BID (32768) + VLAN ID + MAC Address.2. Determine the Root PortsRoot Ports are calculated from the Root Path Cost, which is the following:            Link Speed      STP Cost– 802.1D                  10 Gbps      2              1 Gbps      4              100 Mbps      19              10 Mbps      100      If there is an equal cost path, the root port is elected from:  Lowest SENDER BID  Lowest SENDER port priority  Lowest SENDER port ID3. Determine the Designated PortsThe Designated Ports are the best path to receive traffic leading to the root bridge. If one end is a root port, the other end is a designated port.4. Determine the Blocked PortsAny port that is not a root or designated port is a blocked port."
  }
  
]

